## 상태와 반응성 돌아보기
> 상태는 UI를 표현하고 렌더링하는 데 사용되는 데이터이며, 상태가 변경될 때 UI가 자동으로 업데이트되는 원리를 반응성이라 한다.
> 이 두 개념을 깊이 있게 탐구해보자.

### 4.1 상태와 반응성을 돌아봐야 하는 이유
- "어떤 데이터를 상태로 만들 것인가?"
- "컴포넌트 간에 상태를 어떻게 공유하고 전달할 것인가?"
- 모든 프론트엔드 개발자의 숙제

### 4.2 상태와 설계 컴포넌트
웹 애플리케이션의 상태는 관리 주체와 역할에 따라 크게 서버 상태와 클라이언트 상태로 나뉜다.
- 서버 상태 : 데이터베이스의 원시 데이터 기반으로 비즈니스 로직에 따라 가공된 상태
- 클라이언트 상태: 서버로부터 받은 데이터를 화면에 표시하기 위해 사용되거나 모달의 열림/닫힘 여부와 같이 UI와 직접적인 상호작용을 위해 사용됨.

복잡한 UI로직과 데이터를 효과적으로 관리하기 위해 등장한 것이 디자인 패턴.

#### 4.2.1 UI, 인터랙션을 담당하는 VIEW
MVC, MVP, MVVM, FLUX 와 같은 디자인 패턴은 애플리케이션을 구성하는 각 구성요소를 역할에 따라 명확히 분리해 코드의 가독성과 확장성을 높이는 것을 목표로 삼음.

뷰는 프레젠테이션 레이어라고도 불리며, 유저가 화면에서 보고 직접 상호작용하는 모든 것을 책임짐.
ex) 리액트에서의 뷰는 JSX로 작성된 선언적인 UI 컴포넌트가 뷰에 해당됨.

뷰는 상태가 변경되면 자동으로 업데이트 된다는 반응성을 가진다.
**사용자에게 최전선에 위치하는 인터페이스**

#### 4.2.2 데이터를 담당하는 모델
모델은 애플리케이션의 데이터와 그 데이터를 처리하는 비즈니스 로직을 모두 포함하는 부분. 이 데이터가 변경되면 이 데이터를 구독하던 뷰는 화면을 자동으로 업데이트

- 프론트엔드 : 클라이언트 상태와 그 상태를 관리하는 로직이 모델에 해당. 복잡해짐에 따라 리덕스, 주스탠드, 몹액스와 같은 전역 상태 관리 라이브러리를 사용해 모델을 구축한다.

다음은 유저 목록을 관리하는 프론트엔드 모딜의 구현 예시
```typescript
const userModel = {
  users: [], // users 객체는 뷰를 위해 관리하는 클라이언트 상태 값입니다.
  fetchUsers: async () => {
    const response = await fetch('/api/users'); // fetch API를 사용해 서버에서 유저 데이터를 가져옵니다.
    userModel.users = await response.json();
  },
};
```
모델의 상태 변경이 곧 애플리케이션 전체의 변화를 이끌어낸다.

#### 4.2.3 모델과 뷰를 이어주는 중재자
뷰와 모델은 각자의 역할을 UI렌더링과 데이터 관리에만 집중해야 함.
뷰는 모델의 존재를, 모델은 뷰의 존재를 직접 알아서는 안됨.
이를 이어주는 것이 중재자.

- MVC -> Controller
- MVP -> Presenter
- MVVM -> ViewModel
- Flux - Action and Store

이름은 다르지만 이들이 수행하는 핵심 역할은 유사하다.
전통적인 웹 개발에서는 모델, 뷰 , 컨트롤러를 별개의 파일이나 클래스로 명확하게 분리함. 하지만 리액트와 같은 모던 프레임워크에서는 경계가 유연해짐.

- 리액트 컴포넌트 안에서 useState로 상태(모델) 를 정의하고, 이벤트 핸들러 함수로 유저 입력에 반응해 상태를 변경하는 로직(중재자) 을 작성하고, JSX로 UI(뷰)를 반환함.

### 4.3 주요 디자인 패턴을 사용한 반응성 구현
프레임워크의 도움 없이 상태 변경을 감지하고 DOM의 어느 부분을 어떻게 효율적으로 업데이트 할 지 결정하는 반응형 시스템을 직접 구축한다면 많은 양의 코드를 작성해야 한다.
모던 프레임워크가 내부적으로 어떤 문제를 해결해주고, 그로 인해 개발자가 얼마나 생산성 증대의 혜택을 누리고 있는지 체감해보자.

#### 4.3.1 비 반응성 MVC 패턴 중재자 만들기
```typescript
// 각 파일에서 Model, View, Controller 클래스를 임포트함
import { TodoModel } from './TodoModel.js';
import { TodoView } from './TodoView.js';
import { TodoController } from './TodoController.js';

// 각 클래스의 인스턴스를 생성하고, Controller에 Model과 View를 주입하여 앱을 초기화함
const app = new TodoController(new TodoModel(), new TodoView());
```

#### 4.3.2 MVC 패턴에 반응성 주입하기

앞서 작성한 비 반응성 MVC 패턴의 가장 큰 특징은 컨트롤러가 모델의 상태를 변경할 때 마다 뷰의 렌더링 함수를 직접 호출해야 한다는 점.

**TodoModel**
```typescript
export class TodoModel {
  constructor() {
    this.todos = [];
    // ➊ 상태 변경을 통지할 구독자(리스너) 콜백 함수 목록
    this.listeners = []; 
  }

  // ➋ 외부에서 모델의 변경을 감지할 수 있도록 리스너를 등록(구독)하는 메서드
  subscribe(listener) {
    this.listeners.push(listener);
  }

  // ➌ 등록된 모든 리스너에게 현재 상태를 전달하여 변경 사실을 알림
  notify() {
    this.listeners.forEach(listener => listener(this.todos));
  }

  addTodo(todo) {
    this.todos.push(todo);
    this.notify(); // ➍ 상태 변경 후, 모든 구독자에게 알림
  }

  removeTodo(index) {
    this.todos.splice(index, 1);
    this.notify(); // ➎ 상태 변경 후, 모든 구독자에게 알림
  }

  getTodos() {
    return this.todos;
  }
}
```

**TodoController**
```typescript
export class TodoController {
  constructor(model, view) {
    this.model = model;
    this.view = view;

    // ➊ 모델을 구독하고, 변경 알림이 오면 실행할 콜백 함수를 등록
    // 이 콜백 함수는 뷰의 렌더링을 담당함
    this.model.subscribe(todos => {
      this.view.renderTodos(todos);
    });

    // 뷰의 이벤트를 핸들러에 바인딩하는 것은 동일
    this.view.addButton.addEventListener('click', this.handleAddTodo.bind(this));
    this.view.todoList.addEventListener('click', this.handleDeleteTodo.bind(this));

    // 초기 렌더링
    this.view.renderTodos(this.model.getTodos());
  }

  handleAddTodo() {
    const todoText = this.view.input.value.trim();
    if (todoText) {
      this.model.addTodo(todoText); // 모델 변경만 요청함
      this.view.input.value = '';
    }
  }

  handleDeleteTodo(event) {
    if (event.target.tagName === 'BUTTON') {
      const index = parseInt(event.target.dataset.index, 10);
      this.model.removeTodo(index); // 모델 변경만 요청함
    }
    // ➋ 뷰를 수동으로 업데이트하던 `this.updateView()` 코드가 사라짐
  }
}
```


- 데이터 소스인 모델이 변경되었을 때 자신에게 의존하는 객체인 리스너들에게 자동으로 알람을 보내 업데이트 하는 디자인 패턴을 관찰자 패턴.
