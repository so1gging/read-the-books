## UI 컴포넌트의 위상 돌아보기
> 프론트엔드 개발에서 UI 컴포넌트가 갖는 위상을 알아보자

### 3.1 UI 컴포넌트의 위상을 돌아봐야 하는 이유
1. 리액트의 JSX는 UI 컴포넌트를 만들기 위한 '도구' 일 뿐, 컴포넌트의 본질이 아니다. 컴포넌트의 진짜 본질은 추상화, 인터페이스 설계, 캡슐화 이다. 순수한 자바스크립트 만으로 어떻게 독립적인 조각으로 나눌 수 있을 지 고민해보자.
2. 훌륭한 컴포넌트는 그 자체로도 잘 만들어진 작은 '제품' 과 같다. 프레임워크가 제공하는 편리함에만 의존하면, 우리는 '어떻게' 이 컴포넌트를 만들지에만 집중하게 될 수 있다. '무엇을' 만들고 '어떻게' 상호작용 해야 하는지에 대한 설계관점으로 가야 한다. 이는 유지보수하기 쉽고 재사용성 높은 아키텍처를 설계하는 능력을 길러준다.
3. 프레임워크의 도움 없이도 문제를 해결할 수 있는 탄탄한 기본기를 다져준다.
- 라이브러리와 프레임워크의 유저에서 벗어나 컴포넌트의 설계자로 거듭나자.

### 3.2 프론트엔드 개발에서 UI컴포넌트의 위상
- 레이아웃과 색상,폰트 크기와 같은 규격들을 재사용 가능한 컴포넌트 코드로 변환하여 만들어 낼 수 있어야 한다.
- 디자인토큰을 사용해 명확한 이름으로 소통할 수 있어 팀 전체의 생산성이 향상된다.
- 본인이 작성하는 UI 컴포넌트가 제품에 전반적인 영향을 미친다는 사실을 인지할 수 있어야 함.

### 3.3 UI컴포넌트의 추상화, 인터페이스, 캡슐화
- 프레임워크나 라이브러리를 사용하지 않고도 프론트엔드를 개발할 수 있는 능력이 필요하다.
- **추상화**는 **공통 특성을 일반화하고, 복잡한 세부사항을 감춰 간결한 모델로 표현하는 과정.**
- **인터페이스**는 **추상회된 컴포넌트가 외부에 약속으로 제시하는 공개 API의 집합.**
  - 컴포넌트를 사용하는 외부 코드에서는 이 약속에 의존하고 있기 때문에 인터페이스는 변경해서는 안됨.
- UI컴포넌트에 내부 구현이 어떻게 되어있는지 알 필요가 없다. 추상화 덕분.
  - 버튼 컴포넌트는 `useState()` 를 이용해 포커싱 및 로딩 상태를 내부적으로 관리하지만, 외부에는 `<Button disabled onClick{...}/>` 과 같은 간결한 인터페이스만 노출함.
- 지연로딩을 수행하는 이미지 컴포넌트를 추상화한다고 가정
  - 이미지 UI 컴포넌트는 내부적으로 이미지 다운로드 시 지연로딩이 동작할 수 있도록 구현되어 있으나, 사용자에게 구현방식을 노출하지 않음 -> **추상화**
  - 개발자는 프롭스를 통해 이미지 컴포넌트를 사용할 수 있음 -> **인터페이스**
- 추상화 과정에 캡슐화 라는 개념이 있다.
  - 캡슐화는 추상화를 구현하는 기술적 수단으로 데이터 보호 및 내부 구현 숨김을 위해 모듈화와 유지보수성을 높일 목적으로 사용됨.
    - 자바스크립트에서는 클래스기반 코드에서는 private 필드와 method 로 함수기반 코드에서는 closure 로 구현함.

### 3.4 바닐라 자바스크립트로 컴포넌트 만들기

```javascript
 <script>
        // 네트워크 지연을 시뮬레이션하기 위한 값들 (단위: ms)
        const NETWORK_CONDITIONS = {
            fast3g: { min: 500, max: 1500 },
            slow3g: { min: 1000, max: 3000 },
            '2g': { min: 2000, max: 5000 }
        };

        class LazyImageLoader {
            #loadingStates; // 어떤 image 엘리먼트에 로딩 효과가 필요한지 저장하기 위한 내부 상태값입니다.

            // 기본 옵션 초기화
            constructor(options = {}) { 
                this.options = { // 클래스를 인스턴스화할 때 전달되는 options 값을 가지고 내부에서 사용할 기본 속성들을 초기화 합니다.
                    ...options
                };

                this.observer = new IntersectionObserver( // 인터섹션옵저버를 사용해 화면에 엘리먼트가 노출되었는지 확인합니다.
                );

                // 키 유형이 객체만 가능. 키 객체가 참조 해제되면 값도 자동 제거
                this.#loadingStates = new WeakMap(); // WeakMap을 사용해 image 엘리먼트가 돔에서 사라지면 가비지 콜렉터가 관련 상태값을 더 이상 메모리에 저장하지 않게 합니다.
            }

            observe(selector) { // 돔 API인 querySelectorAll을 사용해 이미지 엘리먼트를 선택하여 이미지를 다운받기 시작합니다.
                const images = document.querySelectorAll(selector);
                images.forEach(img => this.#setupImage(img)); // 이미지 엘리먼트를 대상으로 다운받을 이미지와 로딩 이팩트를 설정합니다.
            }

            #setupImage(img) { // LazyImageLoader의 options로 전달된 값을 사용해 로딩 스피너 혹은 블러 이팩트를 구현합니다.
            }

    </script>
```
- UI를 만들 때 HTML와 자바스크립트를 분리해서 작성하기 때문에 더 어색하게 느껴질 수 있다.

### 3.5 웹 컴포넌트 API를 사용해 컴포넌트 만들기
- 웹 컴포넌트는 프론트엔드 마이크로서비스에서 여러 다른 프레임워크 간 같은 UI 컴포넌트를 사용해야 할 때 유용하게 사용되는 구현방법.


