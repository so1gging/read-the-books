## 프론트엔드 구성요소와 발전 과정 돌아보기

> 프론트 개발이 어떤 방법과 이유로 발전해왔는지 알아보자

### 1.1 프론트엔드의 구성 요소와 발전 과정을 돌아봐야 하는 이유
- 역사를 공부하는 것은 우리가 사용하고 있는 기술들의 근본적인 '왜' 를 이해하고 미래 기술 변화를 예측할 수 있음.

### 1.2 웹 개발과 프론트엔드가 차지하는 위상과 구성 요소
- 웹 개발은 어느 쪽에 중점을 두냐에 따라 Server-side 개발과 Client-side 개발로 나뉜다.
- 클라이언트 사이드 개발을 `프론트 개발` 이라고 부른다.

### 1.3 초창기 웹 프론트엔드
- 초창기 웹 프론트엔드는 정적인 HTML 문서로 구성 
  - 유저가 웹사이트를 방문하면, 서버는 완성된 html 을 서빙하는 방식
  - CSS가 없었기 때문에 모든 디자인 요소가 HTML 태그 안에 직접 포함.
- 2000년대 초반 브라우저 안정화로 인해 CSS가 널리 사용되고 DOM을 조작하는 방식이 발전
  - 자바스크립트에서의 `DOM(Docyment Object Model)` HTML문서를 트리구조로 표현하여 자바스크립트로 요소를 동적으로 조작할 수 있게 해주는 인터페이스
- Ajax 개념을 정립하면서 웹페이지를 새로고침 하지 않아도 서버와 데이터를 주고받을 수 있게 됨.
- 제이쿼리가 등장하면서 Ajax 요청을 쉽게 처리할 수 있었으나, 클라이언트 측 인터랙션이 점점 더 복잡해지기 시작

### 1.4 모듈의 탄생과 한계
- 초기 웹페이지 방식은 **MPA(Multi Page Application)** 방식
  - 여러 페이지로 이루어짐.
  - MPA 각 페이지는 고유한 URL을 가진 완전한 HTML문서
    - SEO에 유리하지만,
    - 페이지를 이동할 때 마다 서버에서 새로 만들어야 하기 때문에 유저경험 저하
- 이러한 단점을 극복하고자, 여러 페이지에서 공통으로 사용할 코드 조각을 만들어 서로 공유하기 시작
  - 재사용한 코드 JS 파일을 **모듈** 이라 부름.
- 단, 모듈이 많아지며 서로 간에 영향을 미치는 의존성이 생기게 됨.
  - 라이브러리 A를 쓰려면, 모듈 C를 써야함. 모듈 C를 써야하면 모듈 B를 써야함 ..-> 반복
  - 개발자는 스크립트 태그 삽입 순서에 하루를 허비하는 일도 잦았다.

### 1.5 번들러의 탄생
- 위의 모듈의 의존성 문제는 **번들러** 라는 도구로 해결된다.
- 원하는 라이브러리만 요청하면 의존성을 알아서 해결함.
- 개발단계에 모듈 그래프를 분석해 의존성 순서 걱정 없이 import/require 구문을 사용할 수 있게 도와줌.
- 배포 단계에 필요없는 코드를 제거해 번들의 크기를 줄이는 Tree shaking 기능
- 초기 로딩 시간을 최소화해주는 코드 스플리팅 기능 제공.

### 1.6 패키지 매니저의 도입
- 외부 라이브러리를 사용하려면 각 라이브러리 웹사이트를 방문해 JS 파일을 내려받아야 했으나,
- **NPM(Node Pakckage Manager)** 의 등장으로 쉬워졌다.
- `npm install` 과 같은 커맨드 한 줄로 수천 개의 하위 의존성을 트리 형태로 내려받아 `node_modules` 폴더에 배치함.

### 1.7 템플릿 엔진의 도입
- 웹개발이 복잡해지면서 반복되는 HTML 코드와 동적인 콘텐츠를 효율적으로 관리하기 위해 HTML 템플릿 엔진이 등장.
- 이쯤부터 웹 프론트엔드 프로젝트는 흔히 만날 수 있는 체계적 구조를 갖추게 됨
  - src: 소스 코드가 위치
  - public: 정적 파일
  - dist: 번들링된 최종 결과물이 배포될 준비 상태로 저장
  - node_modules: npm 패키지가 설치되는 곳

### 1.8 명령형, 선언형 프로그래밍
- 선언형 프로그래밍
  - 개발자는 상태를 설계하고 선언하는 것에 책임을 가지며, 리액트는 UI 동기화 책임
  - 리액트가 알아서 UI를 갱신하기 때문에 개발자가 직접 DOM을 조작할 필요가 없다.
