## 개발 환경 돌아보기

> 개발 환경 구축 방법을 단계적으로 알아보자.

### 5.1 개발 환경을 돌아봐야 하는 이유

어떤 원리로 빌드 프로세스가 동작하는지, Node.js 는 어떤 원리로 동작하는지 모른다면 보일러플레이트가 제공하는 범위 안에서만 문제를 해결할 수 밖에 없음.

### 5.2 Node.js와 버전 매니저

Node.js 아키텍처에 대해 외우고 있지 않아도 동작하는데 문제는 없지만 콜스택과 이벤트 루프가 실제 코드를 실행할 때 어떻게 동작하는지 이해하고 있어야 디버깅이 용이하다.

#### 동기함수 예제 코드

```typescript
function first() {
  console.log("시작: first()");
  // 시간이 걸리는 동기 작업을 시뮬레이션
  for (let i = 0; i < 1_000_000; i++) {}
  second(); // ➊ second() 호출 -> 콜 스택에 'second' 추가
  console.log("종료: first()");
}

function second() {
  console.log("  시작: second()");
  // 시간이 걸리는 동기 작업을 시뮬레이션
  for (let i = 0; i < 1_000_000; i++) {}
  third(); // ➋ third() 호출 -> 콜 스택에 'third' 추가
  console.log("  종료: second()");
}

function third() {
  console.log("    시작: third()");
  // 시간이 걸리는 동기 작업을 시뮬레이션
  for (let i = 0; i < 1_000_000; i++) {}
  console.trace("현재 콜 스택:"); // ➌ 콜 스택 추적
  console.log("    종료: third()");
}

console.log("프로그램 시작");
first(); // ➍ first() 호출 -> 콜 스택에 'first' 추가
const programStart = Date.now();
console.log(`프로그램 종료 - 총 소요시간: ${Date.now() - programStart}ms`);
```

```
/* 예상 출력:
프로그램 시작
시작: first()
  시작: second()
    시작: third()
    현재 콜스택:
        at third (synchronous.js:31)
        at second (synchronous.js:19)
        at first (synchronous.js:8)
        at Object.<anonymous> (synchronous.js:37)
    종료: third() - 소요시간: Xms
  종료: second() - 소요시간: Xms
종료: first() - 소요시간: Xms
프로그램 종료 - 총 소요시간: Xms
*/
```

- 이처럼 동기코드는 하나의 작업이 끝나야 다음 작업이 시작되는 **블로킹 방식**으로 동작
- 무거운 계산을 수행하는 경우 해당 작업이 끝날 때 까지 메인 스레드가 막혀있게 됨.
- 이러한 방식을 개선하기 위해 비동기 모델을 사용해 백그라운드에서 처리하도록 위임.

```typescript
// 비동기 실행의 이벤트 루프 예제
console.log("프로그램 시작");

// setTimeout을 사용한 비동기 함수 예제
function delayedGreeting() {
  console.log("1. delayedGreeting() 함수 호출됨");
  setTimeout(function timer() {
    // 이 코드는 2초 후에 이벤트 큐에 들어가고, 콜 스택이 비워지면 실행
    console.log("4. 타이머 완료! (2초 후)");
  }, 2000);
  console.log("2. setTimeout이 예약되었지만, 함수는 계속 실행됩니다");
}

function performTask() {
  console.log("3. performTask() 함수 호출됨");
  return new Promise(function performTaskPromise(resolve) {
    // Promise 내부의 코드는 동기적으로 실행
    console.log("   Promise 실행 시작");

    // 비동기 작업 시뮬레이션 (1초 후 완료)
    setTimeout(function timer() {
      console.log("5. Promise 내부의 타이머 완료! (1초 후)");
      resolve("작업 결과 데이터"); // 작업 성공 시 resolve 호출
    }, 1000);

    console.log("   Promise 생성 완료 (비동기 작업은 백그라운드에서 계속됨)");
  });
}

// async/await를 사용한 비동기 함수 예제
async function processData() {
  console.log("6. processData() 함수 호출됨 (async 함수)");
  try {
    // await는 Promise가 해결될 때까지 함수 실행을 일시 중지
    // 하지만 메인 스레드는 차단되지 않음
    const result = await new Promise(function processDataPromise(resolve) {
      console.log("   새 Promise 생성 (0.5초 지연)");
      setTimeout(function timer() {
        resolve("처리된 데이터");
      }, 500);
    });

    console.log(`7. 데이터 처리 완료: ${result}`);
  } catch (error) {
    console.error("   오류 발생:", error);
  }
}

delayedGreeting(); // 타이머 실행 예제
performTask() // 프로미스와 이벤트 큐 실행 예제
  .then(function performTaskResolve(result) {
    console.log(`   Promise 결과 : ${result}`);
    return processData(); // 다음 비동기 작업 체이닝
  })
  .then(() => {
    console.log("8. 모든 비동기 작업 완료");
  });

console.log(
  "메인 스크립트 실행 완료 (비동기 작업들은 백그라운드에서 계속 실행됨)"
);
```

- deplayedGreeting() 함수가 호출되어 콜스택에 추가되고
- setTimeout()을 만나면 브라우저는 2초 타이머와 콜백함수 timer() 웹 API에 등록
- 그리고 즉시 다음 코드를 넘어감.
- 메인스레드는 여기서 타이머가 완료될 때 까지 기다리지 않고 deplayedGreeting()함수가 실행이 끝나고 콜스택에서 제거됨.
- 이후 performTask() 를 만나 실행하게 됨.

이제 모든 동기코드가 실행되었고 콜스택이 모두 비어있다. 현재 웹 API는 2초 타이머와 1초 타이머 총 두 개의 타이머를 백그라운드에서 처리하고 있음.
더이상 콜 스택에 실행되어야 할 함수가 남아있지 않기에, 1초 타이머가 종료되는 시점부터 흐름이 재게.

### 5.2.2 노드버전 매니저

nvm을 사용하면 간단한 명령어로 특정 버전의 node.js를 설치 및 삭제할 수 있음.

### 5.3 패키지 매니저

package.json 에 라이브러리 버전과 이름을 명시한 후 각 패키지 매니저에서 제공하는 명령어를 통해 앱 구동에 필요한 모든 의존성들을 내려받거나 버전을 업데이트 한다.

- pakcage-lock.json, yarn.lock, pnpm-lock.yaml 와 같은 lock파일을 생성하는데, 이 파일에는 현재 프로젝트에 설치된 모든 패키지의 정확한 버전과 그 하위 의존성들의 전체 트리가 기록됨.

#### 유령 의존성 문제 알아보기

유령 의존성은 package.json에 명시되어 있지 않은 의존성 모듈을 코드에서 직접 참조하는 경우를 의미한다.
